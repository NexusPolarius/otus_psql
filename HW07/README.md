# Механизм блокировок

## Подготовка к выполнению ДЗ
Создана ВМ в VirtualBox с ОС Ubuntu 20.04. Установлен PostgreSQL 15 с дефолтными настройками.

## Выполнение ДЗ

1. Настройте сервер так, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200 миллисекунд. Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.
    * настраиваем сервер:
	
      ```locks=# ALTER SYSTEM SET log_lock_waits = on;```
	  
	  ```locks=# ALTER SYSTEM SET deadlock_timeout = 200;```
	  
	  ```locks=# SELECT pg_reload_conf();```
	
    * моделируем ситуацию:

Создал таблицу и заполнил ее данными

```CREATE TABLE accounts(acc_no integer PRIMARY KEY, amount numeric);```

```INSERT INTO accounts VALUES (1,1000.00), (2,2000.00), (3,3000.00);```

Начал апдейт в первой сесси

```BEGIN;```

```UPDATE accounts SET amount = amount - 100.00 WHERE acc_no = 1;```
   
Начал апдейт во второй сесси

```BEGIN;```

```UPDATE accounts SET amount = amount + 100.00 WHERE acc_no = 1;```
   
Второй апдейт заблокирован и через 200 миллисекунд в журнал сообщений добавится об этом запись

```user$ tail -n 10 /var/log/postgresql/postgresql-15-main.log```

<img src="/HW07/xxx/1.PNG" alt="lock1.png" /> 


2. Смоделируйте ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах. Изучите возникшие блокировки в представлении pg_locks и убедитесь, что все они понятны. Пришлите список блокировок и объясните, что значит каждая.

Начал апдейт в первой сесси

```BEGIN;```

```UPDATE accounts SET amount = amount + 100.00 WHERE acc_no = 1;```
   
Начал апдейт во второй сесси

```BEGIN;```

```UPDATE accounts SET amount = amount + 200.00 WHERE acc_no = 1;```

Начал апдейт в третьей сесси

```BEGIN;```

```UPDATE accounts SET amount = amount + 300.00 WHERE acc_no = 1;```

Далее завершим транзакции (COMMIT;) сначало в первой сессии затем во второй и наконец в третьей и посмотрим логи:

<img src="/HW07/xxx/2.png" alt="lock2.png" />

В логах видим, что были заблокированны транзакции из второй и третьей сессии. После завершения транзакции в первой сессии разблокировалась транзакция во второй, а после завершения транзакции во второй сессии разблокировалась транзакция в третьей сессии.

3. Воспроизведите взаимоблокировку трех транзакций. Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?

Начнем апдейты трех разных записей в трех сессиях:

Начал апдейт в первой сесси

```BEGIN;```

```UPDATE accounts SET amount = amount + 100.00 WHERE acc_no = 1;```
   
Начал апдейт во второй сесси

```BEGIN;```

```UPDATE accounts SET amount = amount + 200.00 WHERE acc_no = 2;```

Начал апдейт в третьей сесси

```BEGIN;```

```UPDATE accounts SET amount = amount + 300.00 WHERE acc_no = 3;```

Затем в первой сессии начал апдейт записи с acc_no = 2:

```UPDATE accounts SET amount = amount - 200.00 WHERE acc_no = 2;```

Затем во второй сессии начал апдейт записи с acc_no = 3:

```UPDATE accounts SET amount = amount - 300.00 WHERE acc_no = 3;```

Затем в третьей сессии начал апдейт записи с acc_no = 1:

```UPDATE accounts SET amount = amount - 100.00 WHERE acc_no = 1;```

Получил dedlock

<img src="/HW07/xxx/3.png" alt="lock3.png" />

Выполнил COMMIT; в третьей затем во второй затем в первой сессиях и посмотрел лог:

<img src="/HW07/xxx/4.png" alt="lock4.png" />

В принципе в ситуации разобраться можно т.к. в логах есть все записи о блокировках транзакций и о дедлоке.

4. Могут ли две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where), заблокировать друг друга?

Повторить не смог, но в великом интернете пишут что такая ситуация может произойти если в одном апдейте таблица будет читаться последовательно, а в другом по индексу.
